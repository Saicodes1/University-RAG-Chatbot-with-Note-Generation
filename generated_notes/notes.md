# Introduction to Compilers and Phases

**Note:** This document summarizes key concepts from the provided lecture notes on compiler design.

## Overview

This lecture introduces the fundamental phases of compiler design, focusing on lexical and syntactic structure analysis, intermediate code generation, and code optimization. It explains the overall structure of a compiler and its components.

## Phases of a Compiler

A compiler transforms source code into executable target code through a series of distinct phases. The typical phases are:

1.  **Lexical Analysis (Scanning)**
    *   **Description:** Converts the source code into a stream of tokens. Each token represents a meaningful unit (e.g., identifier, keyword, operator).
    *   **Output:** A stream of tokens.
    *   **Key Points:**
        *   Groups characters into lexemes.
        *   Each lexeme is translated into a token with a name and an optional attribute value (usually a pointer to the symbol table).
        *   The token name indicates the kind of construct/element the token represents

2.  **Syntax Analysis (Parsing)**
    *   **Description:**  Checks if the token stream conforms to the grammar of the source language.  Creates a parse tree (syntax tree) based on the grammar.
    *   **Output:** A parse tree (syntax tree).
    *   **Key Points:**
        *   Uses tokens generated by lexical analysis.
        *   Determines the grammatical structure of the program.
        *   A tree-like representation showing the relationships between the tokens.

3.  **Semantic Analysis**
    *   **Description:**  Checks for semantic errors, such as type mismatches, and gathers information about the program (e.g., data types, variable scopes).
    *   **Output:**  A modified parse tree (often with type information added), and an updated symbol table.
    *   **Key Points:**
        *   Enforces the rules of the language's semantic definition.
        *   Performs type checking (e.g., ensuring an arithmetic operation uses compatible data types).
        *   Builds and maintains the symbol table.

4.  **Intermediate Code Generation**
    *   **Description:**  Generates an intermediate representation (IC) of the source code.  This is a machine-independent representation.
    *   **Output:**  Intermediate Code (IC).
    *   **Key Points:**
        *   IC is low-level and machine-like.
        *   Easy to translate into target machine code.
        *   Common forms include three-address code (TAC).

5.  **Code Optimization**
    *   **Description:**  Improves the intermediate code to produce more efficient target code (faster execution, less memory usage).
    *   **Output:** Optimized Intermediate Code (IC).
    *   **Key Points:**
        *   Can be performed after intermediate code generation (M/C independent) or on the intermediate code itself.
        *   Examples: constant folding, common subexpression elimination.

6.  **Code Generation**
    *   **Description:**  Translates the optimized intermediate code into the target language (machine code or assembly language).
    *   **Output:** Target Code.
    *   **Key Points:**
        *   Decides on register allocation and memory locations.


## Compiler Structure

The compiler is divided into two main parts:

1.  **Front-End:**  Handles lexical and syntactic analysis, semantic analysis, and intermediate code generation.
2.  **Back-End:**  Handles code generation, and optimization.

##  Key Concepts

*   **Pass:** A pass is a single run through a phase of the compiler.  Multiple passes can be combined into a single pass.
*   **Symbol Table:** A data structure that stores information about identifiers (variables, functions, etc.) used in the program. Accessed in every phase of the compiler. Stores names, types, scope, and other relevant attributes.  Often implemented using a hash table for efficient lookup.
*   **Intermediate Code (IC):**  A machine-independent representation of the source code, simplifying the translation process. Three-Address Code (TAC) is a common form.
*   **Code Optimization:** Improving the target code’s performance.

## Error Detection and Reporting

*   Error detection and reporting are performed at every phase of the compiler.
*   Types of errors:
    *   **Lexical error:**  Misspelled identifiers or keywords.
    *   **Syntax error:**  An invalid syntactic structure.
    *   **Semantic error:**  An error in the meaning of the code (e.g., incompatible data types).
    *   **Logical error:** An error in the algorithm itself.

## References

*   Aho, Lam, Sethi and Ullman, “Compilers-Principles, Techniques & Tools”, Pearson/Addison-Wesley, Second Edition, 2013.
*   Elakkiya, AP/CS

## Summary

The compilation process involves a series of carefully orchestrated phases, from analyzing the source code's structure and semantics to generating efficient target code. The symbol table is a central component, facilitating information exchange between phases.  Understanding these phases is crucial for designing and implementing effective compiler systems.
